<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Demo Raw input flow</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.js"></script>
  <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
  <style>
    #block-container {
      position: relative;
    }

    .background-texture {

      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-image: url("https://d1muf25xaso8hp.cloudfront.net/https%3A%2F%2F20cb02826b917f36840900e8977ff34d.cdn.bubble.io%2Ff1696181698567x776969871987046100%2FGroup%2520512821.png?w=&h=&auto=compress&dpr=1&fit=max");
      background-repeat: repeat;
    }

    .connection-path {
      stroke: rgb(2, 8, 9);
      fill: transparent;
      stroke-width: 3px;
      opacity: 0.4;
      pointer-events: auto;
      transition: stroke 0.3s;

    }

    .connection-group:hover .connection-path,
    .connection-group.active .connection-path {
      cursor: pointer;
      stroke: rgb(6, 182, 212);
    }

    .connection-close-btn {
      height: 20px;
      width: 20px;
      background-color: rgba(255, 0, 0, 0.556);
      border-radius: 5px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: '#fff';
      transition: 0.3s;
      color: #fff;
      opacity: 0;
      visibility: hidden;
      position: relative;
      border: none;
      padding: 0;
      cursor: pointer;
    }

    .connection-group:hover .connection-close-btn {
      opacity: 1;
      visibility: visible;


    }

    .connection-close-btn:hover {
      background-color: red;
      opacity: 1;
      visibility: visible;

    }

    .connection-close-btn svg {
      height: 80%;
      width: 80%;
      fill: #fff;
    }

    .drawLine {
      stroke: rgb(53, 53, 53);

      opacity: 1;
    }
  </style>
</head>

<body class="h-screen w-screen p-8 bg-gray-300">
  <div class="fixed bottom-8 left-8 z-10 flex">
    <button id="zoomOut"
      class="h-10 w-10 inline-flex items-center justify-center bg-gray-100 cursor-pointer hover:bg-gray-300 transition text-4xl">-</button>
    <button id="zoomIn"
      class="h-10 w-10 inline-flex items-center justify-center bg-gray-100 cursor-pointer hover:bg-gray-300 transition text-4xl">+</button>
    <button id="reset"
      class="h-10 w-20 inline-flex items-center justify-center bg-gray-100 cursor-pointer hover:bg-gray-300 transition text-xl">Reset</button>
  </div>
  <div class="h-full w-full  overflow-hidden  bg-white relative">

    <div class="min-h-full min-w-full  relative     relative parent-selector transform " id="block-container"
      data-before-width="100%" style="transform-origin: 0px 0px 0px; transform: matrix(1, 0, 0, 1, 1835, 1202.7);">

      <!-- Single box -->
      <div class="draggable w-96 border-1 absolute border-2 border-cyan-300 left-[100px] top-[100px] z-10 " id="block1">
        <h2 class="cursor-grab bg-cyan-300 px-2 py-2 text-center uppercase text-bold">
          Input
        </h2>
        <div>
          <textarea class="w-full h-full" name="" id="" rows="3">
Hello testing 2</textarea>
        </div>
        <div id="fromNode-from1" class="absolute -right-20 top-1/2 -translate-y-2 cursor-pointer">
          <div
            class="from-element from-handle cursor-crosshair from-node-el h-4 w-4 origin-center scale-100 hover:scale-150 transform rounded-md transition-all hover:border-cyan-500 hover:bg-cyan-200 border-[2px] border-cyan-500 bg-cyan-200">
          </div>
          <div>fromNode</div>
        </div>
      </div>
      <!-- End Single box -->

      <!-- Single box -->
      <div class="draggable w-96 border-1 absolute border-2 border-cyan-300 left-[600px] top-[500px] z-10" id="block2">
        <h2 class="cursor-grab bg-cyan-300 px-2 py-2 text-center uppercase text-bold">
          Middle chain
        </h2>
        <div>
          <textarea class="w-full h-full" name="" id="" rows="3">
      Hello</textarea>
        </div>
        <div id="fromNode-from2" class="  absolute -right-20 top-1/2 -translate-y-2 cursor-pointer">
          <div
            class="from-element  from-handle cursor-crosshair from-node-el h-4 w-4 origin-center scale-100 hover:scale-150 transform rounded-md transition-all hover:border-cyan-500 hover:bg-cyan-200 border-[2px] border-cyan-500 bg-cyan-200">
          </div>
          <div>fromNode</div>
        </div>
        <div class="absolute -left-16 top-1/2 -translate-y-2 text-right cursor-pointer" id="toNode-to1">
          <div
            class="to-element  from-handle cursor-crosshair from-node-el h-4 w-4 origin-center scale-100 hover:scale-150 transform rounded-md transition-all hover:border-cyan-500 hover:bg-cyan-200 border-[2px] border-cyan-500 bg-cyan-200 float-right">
          </div>
          <div>toNode</div>
        </div>

      </div>
      <!-- End Single box -->

      <!-- Single box -->
      <div class="draggable w-96 border-1 absolute border-2 border-cyan-300 left-[800px] top-[100px] z-10" id="block3">
        <h2 class="cursor-grab bg-cyan-300 px-2 py-2 text-center uppercase text-bold">
          Middle chain
        </h2>
        <div>
          <textarea class="w-full h-full" name="" id="" rows="3">
      Hello</textarea>
        </div>
        <div id="fromNode-from3" class="absolute -right-20 top-1/2 -translate-y-2 cursor-pointer">
          <div
            class="from-element  from-handle cursor-crosshair from-node-el h-4 w-4 origin-center scale-100 hover:scale-150 transform rounded-md transition-all hover:border-cyan-500 hover:bg-cyan-200 border-[2px] border-cyan-500 bg-cyan-200">
          </div>
          <div>fromNode</div>
        </div>
        <div class="absolute -left-16 top-1/2 -translate-y-2 text-right cursor-pointer" id="toNode-to2">
          <div
            class="to-element from-handle cursor-crosshair from-node-el h-4 w-4 origin-center scale-100 hover:scale-150 transform rounded-md transition-all hover:border-cyan-500 hover:bg-cyan-200 border-[2px] border-cyan-500 bg-cyan-200 float-right">
          </div>
          <div>toNode</div>
        </div>

      </div>
      <!-- End Single box -->

      <!-- Single box -->
      <div class="draggable w-96 border-1 absolute border-2 border-cyan-300 left-[1300px] top-[500px] z-10" id="block4">
        <h2 class="cursor-grab bg-cyan-300 px-2 py-2 text-center uppercase text-bold">
          Middle chain
        </h2>
        <div>
          <textarea class="w-full h-full" name="" id="" rows="3">
      Hello</textarea>
        </div>
        <div id="fromNode-from4" class="absolute -right-20 top-1/2 -translate-y-2 cursor-pointer">
          <div
            class="from-element  cursor-crosshair from-node-el h-4 w-4 origin-center scale-100 hover:scale-150 transform rounded-md transition-all hover:border-cyan-500 hover:bg-cyan-200 border-[2px] border-cyan-500 bg-cyan-200">
          </div>
          <div>fromNode</div>
        </div>
        <div class="absolute -left-16 top-1/2 -translate-y-2 text-right cursor-pointer" id="toNode-to3">
          <div
            class="to-element   cursor-crosshair from-node-el h-4 w-4 origin-center scale-100 hover:scale-150 transform rounded-md transition-all hover:border-cyan-500 hover:bg-cyan-200 border-[2px] border-cyan-500 bg-cyan-200 float-right">
          </div>
          <div>toNode</div>
        </div>

      </div>
      <!-- End Single box -->

      <!-- Single box -->
      <div class="draggable w-96 border-1 absolute border-2 border-cyan-300 left-[750px] top-[1000px] z-10" id="block5">
        <h2 class="cursor-grab bg-cyan-300 px-2 py-2 text-center uppercase text-bold">
          Middle chain
        </h2>
        <div>
          <textarea class="w-full h-full" name="" id="" rows="3">
      Hello</textarea>
        </div>
        <div id="fromNode-from5" class="absolute -right-20 top-1/2 -translate-y-2 cursor-pointer">
          <div
            class="from-element cursor-crosshair from-node-el h-4 w-4 origin-center scale-100 hover:scale-150 transform rounded-md transition-all hover:border-cyan-500 hover:bg-cyan-200 border-[2px] border-cyan-500 bg-cyan-200">
          </div>
          <div>fromNode</div>
        </div>
        <div class="to-element absolute -left-16 top-1/2 -translate-y-2 text-right cursor-pointer" fromnodes="from1"
          id="toNode-to5">
          <div
            class="to-element cursor-crosshair from-node-el h-4 w-4 origin-center scale-100 hover:scale-150 transform rounded-md transition-all hover:border-cyan-500 hover:bg-cyan-200 border-[2px] border-cyan-500 bg-cyan-200 float-right">
          </div>
          <div>toNode</div>
        </div>

      </div>
      <!-- End Single box -->





    </div>
  </div>
  <!-- <script src="https://unpkg.com/@panzoom/panzoom@4.5.1/dist/panzoom.min.js"></script> -->
  <script src='https://unpkg.com/panzoom@9.4.0/dist/panzoom.min.js'></script>

  <script>



    //Make the DIV element draggagle:
    $('.draggable').each(function (i, e) {
      dragElement(e, {
        dragEnd: function (left, top) {


        }
      })

    })


    function dragElement(selector, { dragEnd } = {}) {
      var element = $(selector)[0]
      if (!element) return;
      var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0, top = 0, left = 0;





      function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        var scale = element.getBoundingClientRect().width / element.offsetWidth;

        // calculate the new cursor position:
        pos1 = (pos3 - e.clientX) / scale;
        pos2 = (pos4 - e.clientY) / scale;
        pos3 = e.clientX;
        pos4 = e.clientY;
        top = (element.offsetTop - pos2)
        left = (element.offsetLeft - pos1)
        // set the element's new position:
        $(element).css({ top, left })


      }

      function closeDragElement() {
        /* stop moving when mouse button is released:*/

        $(document).off('mouseup', closeDragElement)
        // call a function whenever the cursor moves:
        $(document).off('mousemove', elementDrag)
        if (dragEnd) dragEnd(left, top)
      }

      function dragMouseDown(e) {

        e.preventDefault();
        // get the mouse cursor position at startup:
        pos3 = e.clientX;
        pos4 = e.clientY;
        top = element.offsetTop;
        left = element.offsetLeft;
        $(element).css({ position: 'absolute', top, left })
        if (Boolean(element.offsetLeft)) {

        }
        $(document).on('mouseup', closeDragElement)
        // call a function whenever the cursor moves:
        $(document).on('mousemove', elementDrag)

      }
      $(element).on('mousedown', dragMouseDown)

    }
  </script>
  <script>




    const sleep = (milliseconds) => {
      return new Promise(resolve => setTimeout(resolve, milliseconds))
    }


    const elem = document.getElementById('block-container')

    var panzoomInstance = panzoom(elem, {
      smoothScroll: false,
      zoomSpeed: 0.045, // 6.5% per mouse wheel event
      transformOrigin: { x: 0.5, y: 0.5 },
      maxZoom: 1.5,
      minZoom: 0.5,
      // bounds: true,
      // center: true,
      beforeMouseDown: function (e) {

        // allow mouse-down panning only if altKey is down. Otherwise - ignore
        var shouldIgnore = !!$(e.target).closest('.draggable')[0];
        return shouldIgnore;
      }
    })



    $(elem).parent().prepend('<svg class="react-flow__background bg-stone-50/40" id="background-texture"  style = "position: absolute; width: 100%; height: 100%; top: 0px; left: 0px;" > <pattern id="pattern" x="79.43478586053243" y="6.86162564260303" width="100" height="100"   patternUnits="userSpaceOnUse" patternTransform="translate(-6.25,-6.25)"> <circle cx="6.25" cy="6.25" r="6.25" fill="#e7e5e4"></circle>  </pattern>   <rect x="0" y="0" width="100%" height="100%" fill="url(#pattern)"><rect> </svg >');

    var dotGap = 40
    var offset = 2;
    var patternSize = 5;
    panzoomInstance.on('transform', function (e) {
      // This event will be called along with events above.
      var transform = e.getTransform()

      var scaledGap = dotGap * transform.scale;
      var scaledSize = patternSize * transform.scale;
      var patternOffset = scaledSize / offset

      var radius = scaledSize / offset

      $('#background-texture pattern').attr({ width: scaledGap, height: scaledGap, patternTransform: `translate(-${patternOffset},-${patternOffset})`, x: transform.x % scaledGap, y: transform.y % scaledGap })
      $('#background-texture circle').attr({ cx: radius, cy: radius, r: radius })





    });



    function getTransformOriginOffset() {
      var ownerRect = elem.getBoundingClientRect();
      let transformOrigin = panzoomInstance.getTransformOrigin();


      return {
        x: ownerRect.width * transformOrigin.x, y: ownerRect.height * transformOrigin.y
      }
    }
    function panZoomIn() {
      var offset = getTransformOriginOffset()

      panzoomInstance.smoothZoom(offset.x, offset.y, 1.1);
    }
    function panZoomOut() {
      var offset = getTransformOriginOffset();
      panzoomInstance.smoothZoom(offset.x, offset.y, 0.9)
    }


    function panResetHandler(initiate) {

      const scale = panzoomInstance.getTransform().scale
      const maxScale = panzoomInstance.getMaxZoom()
      const minScale = panzoomInstance.getMinZoom()
      const offsetWidth = elem.offsetWidth
      const offsetHeight = elem.offsetHeight
      const containerRect = elem.getBoundingClientRect()


      var minX, minY, maxX, maxY;
      $('.draggable').each(function (i, e) {
        const rect = e.getBoundingClientRect()

        if (!minX) {
          minX = rect.left;
        } else if (minX > rect.left) {
          minX = rect.left
        }


        if (!minY) {
          minY = rect.top;
        } else if (minY > rect.top) {
          minY = rect.top
        }

        if (!maxX) {
          maxX = rect.right;
        } else if (maxX < rect.right) {
          maxX = rect.right
        }



        if (!maxY) {
          maxY = rect.bottom;
        } else if (maxY < rect.bottom) {
          maxY = rect.bottom
        }


      })
      const width = Math.abs((minX - maxX) / scale)
      const height = Math.abs((minY - maxY) / scale)


      let targetScale = Math.min(elem.offsetWidth / width, elem.offsetHeight / height)


      if (targetScale > maxScale) {
        targetScale = maxScale
      }
      if (targetScale < minScale) {
        targetScale = minScale
      }
      console.log(targetScale)
      const scaleWidth = width * targetScale;
      const scaleHeight = height * targetScale;

      let addJustX = 0;
      let addJustY = 0;




      if (offsetWidth > scaleWidth) {
        addJustX = ((offsetWidth - scaleWidth)) / 2
      }
      if (offsetHeight > scaleHeight) {

        addJustY = (offsetHeight - scaleHeight) / 2
      }


      if (offsetWidth < scaleWidth) {

        addJustX = -(scaleWidth - offsetWidth) / 2
      }
      if (offsetHeight < scaleHeight) {

        addJustY = -(scaleHeight - offsetHeight) / 2
      }


      const x = containerRect.x - minX + addJustX;
      const y = containerRect.y - minY + addJustY


      panzoomInstance.zoomAbs(0, 0, targetScale);
      panzoomInstance.moveTo(x, y)

      if (initiate.isReset === false) {
        initiate.isReset = true;
        setTimeout(panResetHandler, 50)

      }

    } // end Pan reset handler

    function panReset() {
      const initiate = { isReset: false }
      panResetHandler(initiate)
    }



    $('#zoomOut').on('click', panZoomOut)
    $('#zoomIn').on('click', panZoomIn)
    $('#reset').on('click', panReset)





  </script>



  <script>

    // ==========================
    // Plugin script
    // ==========================
    var w3u = 'http://www.w3.org/2000/svg';
    var TRANSLATION_DEFAULT = 0.3
    var DIRECTION = {
      TOP_LEFT: 'top-left',
      TOP: 'top',
      TOP_RIGHT: 'top-right',
      RIGHT: 'right',
      BOTTOM_LEFT: 'bottom-left',
      BOTTOM: 'bottom',
      BOTTOM_RIGHT: 'bottom-right',
      LEFT: 'left',
    };
    var svgIcon = '<svg class="connection-close-icon"  id="Layer_1"  version="1.1" viewBox="0 0 512 512" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M443.6,387.1L312.4,255.4l131.5-130c5.4-5.4,5.4-14.2,0-19.6l-37.4-37.6c-2.6-2.6-6.1-4-9.8-4c-3.7,0-7.2,1.5-9.8,4  L256,197.8L124.9,68.3c-2.6-2.6-6.1-4-9.8-4c-3.7,0-7.2,1.5-9.8,4L68,105.9c-5.4,5.4-5.4,14.2,0,19.6l131.5,130L68.4,387.1  c-2.6,2.6-4.1,6.1-4.1,9.8c0,3.7,1.4,7.2,4.1,9.8l37.4,37.6c2.7,2.7,6.2,4.1,9.8,4.1c3.5,0,7.1-1.3,9.8-4.1L256,313.1l130.7,131.1  c2.7,2.7,6.2,4.1,9.8,4.1c3.5,0,7.1-1.3,9.8-4.1l37.4-37.6c2.6-2.6,4.1-6.1,4.1-9.8C447.7,393.2,446.2,389.7,443.6,387.1z"/></svg>'

    function pointBezier(point, containerVisibleSize) {
      // console.log(point, containerVisibleSize.width, point.translation[0]);
      return {
        x: point.x + containerVisibleSize.width * point.translation[0],
        y: point.y + containerVisibleSize.height * point.translation[1],
      }
    } // end pointBezier


    function nodeValue(node) {
      var nodeSelected = node
      if (typeof node === 'function') {
        nodeSelected = node()
      }


      if (!document.body.contains(nodeSelected)) return null;

      return nodeSelected;
    }; // end nodeValue

    function getAnchorPoint(anchor, svg) {
      // console.log(svg);
      var node = nodeValue(anchor.node);
      if (!node && (!anchor.x || !anchor.y)) {

        throw new Error("point is null, check if 'from'/'to' exists")
      };

      var x, y;
      var svgRect = svg.getBoundingClientRect()
      // Get current scale
      var containerElement = svg.parentElement;
      var scaleValue = containerElement.getBoundingClientRect().width / containerElement.offsetWidth

      if (anchor.x && anchor.y) {
        x = (anchor.x - svgRect.x) / scaleValue;
        y = (anchor.y - svgRect.y) / scaleValue

        return { x, y }
      }



      var rect = node.getBoundingClientRect();

      x = (rect.x - svgRect.x) / scaleValue;
      y = (rect.y - svgRect.y) / scaleValue;

      var nodeWidth = rect.width / scaleValue;
      var nodeHeight = rect.height / scaleValue;



      switch (anchor.direction) {
        case DIRECTION.TOP_LEFT:
          return { x, y };
        case DIRECTION.TOP:
          return {
            x: x + nodeWidth / 2,
            y: y,
          };
        case DIRECTION.TOP_RIGHT:
          return {
            x: x + nodeWidth,
            y: y,
          };
        case DIRECTION.RIGHT:
          return {
            x: x + nodeWidth,
            y: y + nodeHeight / 2,
          };
        case DIRECTION.BOTTOM_LEFT:
          return {
            x,
            y: y + nodeHeight,
          };
        case DIRECTION.BOTTOM:
          return {
            x: x + nodeWidth / 2,
            y: y + nodeHeight,
          };
        case DIRECTION.BOTTOM_RIGHT:
          return {
            x: x + nodeWidth,
            y: y + nodeHeight,
          };
        case DIRECTION.LEFT:
          return {
            x,
            y: y + nodeHeight / 2,
          };
        default:
          return {
            x: x + rect.width / 2,
            y: y + nodeHeight / 2,
          }
      }
    }; // end getAnchorPoint

    function castToAnchor(anchorParam) {
      if (typeof anchorParam === 'function' || anchorParam instanceof HTMLElement) return {
        node: anchorParam,
      }

      return anchorParam
    } // end castToAnchor

    function createAnchorWithPoint(
      anchorParam, svg
    ) {
      var anchor = castToAnchor(anchorParam)
      var position = getAnchorPoint(anchor, svg);

      return {
        ...anchor,
        ...position,
      };
    }; // end createAnchorWithPoint




    function autoAnchorWithPoint(pointA, pointB, svg) {
      if (pointA.translation && pointA.direction) return pointA

      var autoAnchor = { ...pointA };

      var setDirectionWhenEmpty = (direction) => {
        if (!autoAnchor.direction) autoAnchor.direction = direction;
      }

      var setTranslationWhenEmpty = (translation) => {
        if (!autoAnchor.translation) autoAnchor.translation = translation;
      }

      var setParamsWhenEmpty = (direction, translation) => {
        setDirectionWhenEmpty(direction);
        setTranslationWhenEmpty(translation);
      }

      var xDiff = Math.abs(pointA.x - pointB.x);
      var yDiff = Math.abs(pointA.y - pointB.y);

      if (xDiff > yDiff) {
        if (pointA.x < pointB.x) setParamsWhenEmpty(DIRECTION.RIGHT, [TRANSLATION_DEFAULT, 0])
        else setParamsWhenEmpty(DIRECTION.LEFT, [-TRANSLATION_DEFAULT, 0])
      } else {
        if (pointA.y < pointB.y) setParamsWhenEmpty(DIRECTION.BOTTOM, [0, TRANSLATION_DEFAULT])
        else setParamsWhenEmpty(DIRECTION.TOP, [0, -TRANSLATION_DEFAULT])
      }

      return createAnchorWithPoint(autoAnchor, svg)
    } // end autoAnchorWithPoint



    function containerSize(relativeFrom, relativeTo) {

      return {
        width: Math.abs(relativeFrom.x - relativeTo.x),
        height: Math.abs(relativeFrom.y - relativeTo.y),
      }
    }; // end containerSize


    function pointToArray(point) {
      return [
        point.x,
        point.y,
      ]
    }; // end pointToArray

    function convertPathToSVG(path) {
      var list = ['M'];
      list.push(pointToArray(path[0]));
      list.push('C');
      list.push(pointToArray(path[1]));
      list.push(',');
      list.push(pointToArray(path[2]));
      list.push(',');
      list.push(pointToArray(path[3]));
      return list.flat().join(' ').replace(/ ,/g, ',');
    }; // convertPathToSVG






    function pathListBezier(
      container,

    ) {
      var path = [];

      path.push(container.relativeFrom);
      path.push(pointBezier(container.relativeFrom, container.size));
      path.push(pointBezier(container.relativeTo, container.size));
      path.push(container.relativeTo);

      return path;
    }; //end pathListBezier 

    function createPaths(from, to, svg) {
      var fromAnchor = createAnchorWithPoint(from, svg);
      var toAnchor = createAnchorWithPoint(to, svg);

      var relativeFrom = autoAnchorWithPoint(fromAnchor, toAnchor, svg)
      var relativeTo = autoAnchorWithPoint(toAnchor, fromAnchor, svg)

      var position = {
        x: Math.min(relativeFrom.x, relativeTo.x),
        y: Math.min(relativeFrom.y, relativeTo.y),
      };

      var size = containerSize(relativeFrom, relativeTo);

      var path = pathListBezier({ position, size, relativeFrom, relativeTo });
      return { path: convertPathToSVG(path), position: position, size: size };
    } // end createPaths

    function getSvgEl(parrent = 'body') {
      var svg = $(parrent + ' #connection-svg')[0];
      if (!svg) {
        var svgParentEl = $(parrent)[0]

        svg = $(document.createElementNS(w3u, 'svg')).attr('id', 'connection-svg').css({ width: svgParentEl.scrollWidth, height: svgParentEl.scrollHeight, left: 0, top: 0, position: 'absolute', overflow: 'visible' }).appendTo(svgParentEl)[0]


        $(svgParentEl).on('scroll', function () {
          $(svg).css({ width: this.scrollWidth, height: this.scrollHeight })

        })
        $(window).on('resize', function () {
          $(svg).css({ width: svgParentEl.scrollWidth, height: svgParentEl.scrollHeight })

        })

      }
      return svg
    } // End getSvgEl

    function createElements(svg, pathCommands, closeBtn = true) {
      var groupElement = $(document.createElementNS(w3u, 'g')).addClass('connection-group').appendTo(svg)
      var pathEl = $(document.createElementNS(w3u, 'path')).addClass('connection-path').attr({ 'd': pathCommands.path, }).appendTo(groupElement)[0]



      // btn
      var $btn
      if (closeBtn) {
        var foreignObject = $(document.createElementNS(w3u, 'foreignObject')).appendTo(groupElement)
        $btn = $('<button>').addClass('connection-close-btn').html(svgIcon).appendTo(foreignObject)
        var buttonSize = '20'
        foreignObject.css({ height: buttonSize, width: buttonSize })

        $(groupElement).hover(function () {
          var containerElement = svg.parentElement;
          var scaleValue = containerElement.getBoundingClientRect().width / containerElement.offsetWidth
          var pathRect = pathEl.getBoundingClientRect()
          var svgRect = svg.getBoundingClientRect()
          var buttonWidth = $($btn).width();
          var buttonHeight = $($btn).height();
          var pathX = pathRect.x / scaleValue;
          var pathY = pathRect.y / scaleValue;
          var pathWidth = pathRect.width / scaleValue;
          var pathHeight = pathRect.height / scaleValue;
          foreignObject.attr({ x: (((pathWidth / 2) + pathX - buttonWidth / 2) - svgRect.x / scaleValue), y: (pathHeight / 2 + pathY - buttonHeight / 2) - svgRect.y / scaleValue })

        })
      }


      return { groupElement: groupElement, pathEl: pathEl, btn: $btn }
    } // create elements


    function arrowVector(
      options
    ) {

      var from = options.from;
      var fromId = from.id
      if (fromId) {
        from.node = $('#' + fromId).find('.from-element')[0]
      }
      var to = options.to;
      var toId = to.id
      if (toId) {
        to.node = $('#' + toId).find('.to-element')[0]
      }
      var autoUpdate = options.autoUpdate;
      var closeHandler = options.closeHandler;
      var pathClass = options.pathClass || '';
      var svg = getSvgEl(options.parent)


      var pathCommands = createPaths(from, to, svg)
      var elements = createElements(svg, pathCommands, options.closeButton)
      var groupElement = elements.groupElement
      $(groupElement).attr({ from: fromId, to: toId })
      var pathEl = elements.pathEl
      $(pathEl).addClass(pathClass)
      var $btn = elements.btn
      var intervalId;

      if (autoUpdate) {
        intervalId = setInterval(function () {
          if (groupElement[0].isConnected) {
            var updatedPathCommands = createPaths(from, to, svg)

            // Only update when path is changed
            if (pathCommands.path !== updatedPathCommands.path) {

              $(pathEl).attr('d', updatedPathCommands.path)
            }
            return;
          }
          clearInterval(intervalId)
        }, 0)
      }

      function updateHandler(options) {
        if (options.form) {
          from = options.form
        }
        if (options.to) {
          to = options.to
        }
        var updatedPathCommands = createPaths(from, to, svg)
        $(pathEl).attr('d', updatedPathCommands.path)
      }


      $(groupElement).on('click', function (e) {
        e.stopPropagation()
        $('.connection-group').removeClass('active')
        $(this).addClass('active')
      })




      function remove() {


        groupElement.remove()
        clearInterval(intervalId)
      }


      if ($btn) {
        $($btn).on('click', function () {
          if (typeof closeHandler === "function") { closeHandler(from, to) }
          remove()

        })
      }

      return { update: updateHandler, remove: remove }


    };
    function outsideGroupClickHandler(e) {
      $('.connection-group').removeClass('active')
    }
    $(document).on('click', outsideGroupClickHandler)
  </script>

  <script>

    // =============================
    // Start drag functions 
    // =============================
    var dragFromBlock = null
    var dragLine = null;
    var mousePosition = { x: 0, y: 0 }

    function dragLineRemoveHandler() {
      if (dragFromBlock && dragLine && dragLine.remove) {
        dragLine.remove()
        dragLine = null;
        dragFromBlock = null;
      }
    }

    function dragStartHandler(dragFromId) {
      setTimeout(function () {

        // First remove old dragline 
        dragLineRemoveHandler()
        dragFromBlock = $('#' + dragFromId);
        dragLine = arrowVector(
          {
            from: {
              id: dragFromId,
              direction: DIRECTION.RIGHT,
              translation: [0.5, 0],
            },
            to: {

              x: mousePosition.x,
              y: mousePosition.y,
              direction: DIRECTION.LEFT,
              translation: [-0.5, 0],
            }, parent: '#block-container', closeButton: false, pathClass: 'drawLine'
          }
        )
      })
    }

    // Update the dragline
    $(document).on('mousemove', function (e) {
      if (dragLine && dragLine.update) {
        dragLine.update({
          to: {
            x: e.clientX, y: e.clientY, direction: DIRECTION.LEFT,
            translation: [-0.5, 0],
          }
        })

      }
    })

    // Remove dragline when click in the document
    $(document).on('click', function (e) {
      mousePosition = { x: e.clientX, y: e.clientY }
      if (dragFromBlock && $(dragFromBlock)[0].contains(e.target)) return
      if (dragLine && dragLine.remove) {


        dragLine.remove()
        dragLine = null
        dragFromBlock = null
      }
    })
    // End drag functions



    // =============================
    // Start create connection  functions
    // =============================


    function createConnection(fromId, toId) {

      function lineCloseBtnClickHandler() {
        if (typeof bubble_fn_deleteConnection === 'function') bubble_fn_deleteConnection([fromId, toId])
      }
      return arrowVector({
        from: {
          id: fromId,
          direction: DIRECTION.RIGHT,
          translation: [0.5, 0],
        },
        to: {
          id: toId,
          direction: DIRECTION.LEFT,
          translation: [-0.5, 0],
        },
        parent: '#block-container',
        autoUpdate: true,
        closeButton: true,
        closeHandler: lineCloseBtnClickHandler
      }
      )

    }

    function createConnectionFromList(fromList = [], toId) {
      $('.connection-group[to=' + toId + ']').remove()
      fromList.forEach(function (fromId) {
        createConnection(fromId, toId)
      })
    }

    // =============================
    // Delete Block connections
    // =============================

    function deleteBlockConnections(blockId) {
      $('.connection-group[from=' + blockId + '],.connection-group[to=' + blockId + ']').remove()
    }
  </script>
  <!-- 
    <script>



      document.addEventListener("DOMContentLoaded", function () {



        // Attach zoom and pan to the editor container
        var blockContainerObserver = new MutationObserver(function mCallback(mutations, ob) {

          for (let mutation of mutations) {
            if (mutation.type === 'childList') {



              var container = $('#block-container')[0];

              if (container) {

                window.panzoomInstance = panzoom(container, {
                  smoothScroll: false,
                  zoomSpeed: 0.045, // 6.5% per mouse wheel event
                  transformOrigin: { x: 0.5, y: 0.5 },
                  maxZoom: 1.5,
                  minZoom: 0.5,
                  beforeMouseDown: function (e) {
                    // Moveable component mouse down should ignore
                    var shouldIgnore = !!$(e.target).closest('.movable')[0];
                    return shouldIgnore;
                  }
                });


                // If there is no existing background-texture element
                if ($('.background-texture').length === 0) {
                  $(container).prepend($('<span>').addClass('background-texture'));
                }

                // resize background-texture according to transform
                panzoomInstance.on('transform', function (e) {

                  // This event will be called along with events above.
                  var transform = e.getTransform()
                  var width = container.scrollWidth / transform.scale
                  var height = container.scrollHeight / transform.scale
                  $('.background-texture').css({ width: width, height: height, left: -(transform.x / transform.scale), top: -(transform.y / transform.scale) })

                });


                // Get transform origin offset
                window.getTransformOriginOffset = function () {
                  var ownerRect = container.getBoundingClientRect();
                  let transformOrigin = panzoomInstance.getTransformOrigin();
                  var x = ownerRect.width * transformOrigin.x
                  var y = ownerRect.height * transformOrigin.y
                  return {
                    x: ownerRect.width * transformOrigin.x, y: ownerRect.height * transformOrigin.y
                  }
                }

                // Pan zoom in handler
                window.panZoomIn = function () {
                  var offset = getTransformOriginOffset()

                  panzoomInstance.smoothZoom(offset.x, offset.y, 1.1);
                }
                // Pan zoom out handler
                window.panZoomOut = function () {
                  var offset = getTransformOriginOffset();
                  panzoomInstance.smoothZoom(offset.x, offset.y, 0.9)
                }

                // Pan reset handler
                window.panReset = function () {
                  panzoomInstance.moveTo(0, 0, 1);
                  panzoomInstance.zoomAbs(0, 0, 1);
                }
                ob.disconnect()


              };
            }

          }
        });



        // blockContainerObserver.observe(document.body, {
        //   childList: true, subtree: false,
        // });
      })
    </script> -->

  <!-- <script>
                  var click = {
        x: 0,
        y: 0
      };           
                        
                        
       
                      
      $(element).draggable({
refreshPositions:true,

        start: function (e) {


          click.x = e.clientX;
          click.y = e.clientY;
        },
        drag: function (event, ui) {
          var zoom = ui.helper[0].getBoundingClientRect().width / ui.helper[0].offsetWidth;

          var original = ui.originalPosition;

          // jQuery will simply use the same object we alter here
          ui.position = {
            left: (event.clientX - click.x + original.left) / zoom,
            top: (event.clientY - click.y + original.top) / zoom
          };
        }
      })            
                        
                        
                        
                        
                        
                        
         
    </script> -->

  <script>

    $("#fromNode-from1").on('click', function () {

      dragStartHandler('block1')
    });
    createConnection('block1', 'block2')
    createConnection('block3', 'block4')
    createConnection('block1', 'block2')

    // arrowVector(
    //   {
    //     from: {
    //       id: 'block1',
    //       direction: DIRECTION.RIGHT,
    //       translation: [1, 0],
    //     },
    //     to: {
    //       id: 'block2',
    //       direction: DIRECTION.LEFT,
    //       translation: [-1, 0],
    //     }, parent: '#block-container', autoUpdate: false, closeButton: true
    //   }
    // )

  </script>

  <script>

  </script>
</body>

</html>